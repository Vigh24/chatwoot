FROM chatwoot/chatwoot:latest

ARG FRONTEND_URL ACTIVE_STORAGE_SERVICE DATABASE_URL PGHOST PGPORT DEFAULT_LOCALE INSTALLATION_ENV NODE_ENV RAILS_ENV REDIS_URL SECRET_KEY_BASE PORT

RUN apk add --no-cache multirun postgresql-client

# Remove database operations from build phase
# They will be executed during container startup

ENTRYPOINT ["multirun"]

# Create a startup script file directly in the Dockerfile
COPY <<-'EOT' /startup.sh
#!/bin/sh

# Function to extract database connection parameters from DATABASE_URL if needed
setup_db_params() {
  # If PGHOST is empty but DATABASE_URL is set, extract host and port from DATABASE_URL
  if [ -z "$PGHOST" ] && [ -n "$DATABASE_URL" ]; then
    echo "PGHOST is not set, extracting from DATABASE_URL..."
    
    # Extract host and port from DATABASE_URL
    # Format: postgres://username:password@host:port/database
    DB_URL_HOST=$(echo $DATABASE_URL | sed -n 's/.*@\([^:]*\).*/\1/p')
    DB_URL_PORT=$(echo $DATABASE_URL | sed -n 's/.*:\([0-9]*\)\/.*/\1/p')
    
    if [ -n "$DB_URL_HOST" ]; then
      export PGHOST=$DB_URL_HOST
      echo "Extracted PGHOST from DATABASE_URL: $PGHOST"
    fi
    
    if [ -n "$DB_URL_PORT" ]; then
      export PGPORT=$DB_URL_PORT
      echo "Extracted PGPORT from DATABASE_URL: $PGPORT"
    else
      export PGPORT=5432
      echo "Using default PGPORT: 5432"
    fi
  fi
  
  # Set default port if still empty
  if [ -z "$PGPORT" ]; then
    export PGPORT=5432
    echo "PGPORT not set, using default: 5432"
  fi
  
  # If PGHOST is still empty, use default
  if [ -z "$PGHOST" ]; then
    echo "WARNING: PGHOST is not set and could not be extracted from DATABASE_URL"
    echo "Using 'postgres' as default host, but this may not work"
    export PGHOST="postgres"
  fi
}

# Function to check database connection with retries
check_db_connection() {
  echo "Checking database connection..."
  max_retries=30
  retries=0
  
  # Setup database parameters if needed
  setup_db_params
  
  # Print environment variables for debugging (without exposing passwords)
  echo "Database connection parameters:"
  echo "PGHOST: $PGHOST"
  echo "PGPORT: $PGPORT"
  echo "DATABASE_URL is set: $(if [ -n "$DATABASE_URL" ]; then echo "yes"; else echo "no"; fi)"
  
  while [ $retries -lt $max_retries ]; do
    echo "Attempting to connect to PostgreSQL at $PGHOST:$PGPORT..."
    if pg_isready -h $PGHOST -p $PGPORT; then
      echo "Database connection successful!"
      return 0
    fi
    retries=$((retries+1))
    echo "Database connection attempt $retries/$max_retries failed, retrying in 5 seconds..."
    sleep 5
  done
  echo "Could not connect to database after $max_retries attempts"
  return 1
}

# Function to check for required PostgreSQL extensions
check_pg_extensions() {
  echo "Checking for required PostgreSQL extensions..."
  
  # Extract username from DATABASE_URL if available
  local pg_user="postgres"
  if [ -n "$DATABASE_URL" ]; then
    extracted_user=$(echo $DATABASE_URL | sed -n 's/.*:\/\/\([^:]*\):.*/\1/p')
    if [ -n "$extracted_user" ]; then
      pg_user=$extracted_user
    fi
  fi
  
  # Use POSTGRES_USERNAME if set
  if [ -n "$POSTGRES_USERNAME" ]; then
    pg_user=$POSTGRES_USERNAME
  fi
  
  echo "Using database user: $pg_user"
  
  # Connect to PostgreSQL and check if vector extension is available
  if ! psql -h $PGHOST -p $PGPORT -U $pg_user -d postgres -c "SELECT * FROM pg_available_extensions WHERE name = 'vector';" 2>/dev/null | grep -q "vector"; then
    echo "ERROR: PostgreSQL 'vector' extension is not available on the server."
    echo "This extension is required for Chatwoot v4.0+ for AI features."
    echo "Please install the extension on your PostgreSQL server or use a managed PostgreSQL service that supports it."
    echo "For Railway.app: You may need to use a custom PostgreSQL add-on that supports the vector extension."
    echo "See: https://chwt.app/v4/migration for more information."
    return 1
  fi
  
  echo "PostgreSQL vector extension is available."
  return 0
}

# Function to apply vector extension workaround if needed
apply_vector_workaround() {
  local has_vector=$1
  
  if [ "$has_vector" = "false" ]; then
    echo "Applying workaround for missing vector extension..."
    
    # Create a backup of the schema.rb file
    cp /app/db/schema.rb /app/db/schema.rb.bak
    
    # Comment out the vector extension line in schema.rb
    sed -i 's/enable_extension "vector"/# enable_extension "vector" # Temporarily disabled due to missing extension/g' /app/db/schema.rb
    
    # Also comment out vector-related tables and indexes
    sed -i 's/create_table "article_embeddings"/# create_table "article_embeddings" # Temporarily disabled due to missing vector extension/g' /app/db/schema.rb
    sed -i 's/create_table "captain_assistant_responses"/# create_table "captain_assistant_responses" # Temporarily disabled due to missing vector extension/g' /app/db/schema.rb
    sed -i 's/create_table "captain_assistants"/# create_table "captain_assistants" # Temporarily disabled due to missing vector extension/g' /app/db/schema.rb
    sed -i 's/create_table "captain_documents"/# create_table "captain_documents" # Temporarily disabled due to missing vector extension/g' /app/db/schema.rb
    sed -i 's/create_table "captain_inboxes"/# create_table "captain_inboxes" # Temporarily disabled due to missing vector extension/g' /app/db/schema.rb
    
    # Also comment out any vector-related indexes
    sed -i 's/add_index.*vector_idx_knowledge_entries_embedding.*/# & # Temporarily disabled due to missing vector extension/g' /app/db/schema.rb
    sed -i 's/add_index.*embedding.*using: :ivfflat.*/# & # Temporarily disabled due to missing vector extension/g' /app/db/schema.rb
    
    echo "Modified schema.rb to work without vector extension"
    echo "NOTE: AI features will not be available in this deployment"
  fi
}

# Function to restore original schema file
restore_schema_file() {
  if [ -f "/app/db/schema.rb.bak" ]; then
    echo "Restoring original schema.rb file..."
    cp /app/db/schema.rb.bak /app/db/schema.rb
    rm /app/db/schema.rb.bak
  fi
}

# Function to initialize database
init_database() {
  echo "Initializing database..."
  
  # Check for required PostgreSQL extensions first
  local has_vector="true"
  check_pg_extensions || {
    echo "WARNING: Continuing without vector extension. Some AI features will not work."
    has_vector="false"
  }
  
  # Apply workaround if vector extension is not available
  apply_vector_workaround "$has_vector"
  
  # Try to create database if it doesn't exist
  echo "Attempting to create database if it doesn't exist..."
  bundle exec rails db:create 2>/dev/null || echo "Database may already exist, continuing..."
  
  echo "Running chatwoot_prepare..."
  bundle exec rails db:chatwoot_prepare || {
    echo "Database initialization failed during chatwoot_prepare."
    echo "If you see 'extension vector is not available' errors, please see: https://chwt.app/v4/migration"
    restore_schema_file
    return 1
  }
  
  echo "Running schema load..."
  bundle exec rails db:schema:load || {
    restore_schema_file
    return 1
  }
  
  echo "Running migrations..."
  bundle exec rails db:migrate || {
    restore_schema_file
    return 1
  }
  
  # Restore original schema file after successful initialization
  restore_schema_file
  
  echo "Verifying database setup..."
  # Check if installation_configs table exists
  if ! bundle exec rails runner "puts ActiveRecord::Base.connection.table_exists?('installation_configs')" | grep -q "true"; then
    echo "Error: installation_configs table does not exist after migrations"
    return 1
  fi
  
  echo "Database initialization completed successfully"
  return 0
}

# Main execution
if ! check_db_connection; then
  echo "Database connection failed. Exiting."
  exit 1
fi

if ! init_database; then
  echo "Database initialization failed. Exiting."
  exit 1
fi

echo "Starting Chatwoot services..."
exec multirun "bundle exec sidekiq -C config/sidekiq.yml" "bundle exec rails s -b 0.0.0.0 -p $PORT"
EOT

# Make the startup script executable and verify it exists
RUN chmod +x /startup.sh && \
    ls -la /startup.sh && \
    cat /startup.sh

CMD ["/startup.sh"]